100 REM Grayscale 64 R12 Picture Creator - Jan 8, 2023 Monty McGraw102 REM Supports max 128x98 grayscale BMP image103 REM Use GIMP to scale PIC, Mode Grayscale, then Indexed 64, then104 REM Colormap to record indexes, then Grayscale & Export BMP.105 REM Use HxD to paste colormap values to BMP at 0020 and106 REM export BMP file to Motorola S19 ASCII HEX format.108 REM Use Notepad++ to replace CRLF with "CR" to INPUT with this pgm.110 INIT111 REM FNB tests bit X9 (LSB bit 1 to 8) in V9=value, Returns 1 or 0112 DEF FNB(X9)=INT(V9/2^X9-INT(V9/2^X9)+0.5)116 REM X5 & Y5 =absolute D/A X,Y for image lower left corner,N=bytes117 X5=0118 Y5=0119 PRINT "R12 Bitmap CREATOR Program - Jan 8, 2023 MCM"120 WINDOW 0,130,0,100121 DIM P$(12544),A$(74)122 REM initialize 64 Grayscale 8x8 patterns as ASCII HEX DOT X/Y bytes130 GOSUB 1000220 PRINT "Enter S19 ASCII DATA file number: ";240 INPUT F250 FIND @5:F260 INPUT @5,19:A$270 B$=SEG(A$,8,1)280 L=LEN(A$)290 S$=SEG(A$,38,L-38+1)300 S=VAL(S$)310 IF B$="A" THEN 390320 PRINT "Flash Drive file# ";F;" is not an ASCII file. Press ENTER:";325 INPUT A$330 GO TO 210390 PAGE410 FIND @5:F430 INPUT@5:A$440 REM discard first $, check 2nd for BM" then for Image Width & Length450 INPUT@5:A$460 B$=SEG(A$,9,4)470 IF B$="424D" THEN 500480 PRINT "Not BMP S19 file format.Stop Tera Term file transfer!"490 GO TO 340500 B$=SEG(A$,43,4)505 P$=""510 CALL "HEXDEC",B$,W0520 B$=SEG(A$,51,4)530 CALL "HEXDEC",B$,H0540 IF W0<129 AND H0<99 THEN 570550 PRINT "Image is too Wide or too High: W=";W0;" H=";H0560 GO TO 340570 REM now read 64 Gray mapping values571 INPUT@5:A$572 FOR I=1 TO 64573 IF I<>33 THEN 575574 INPUT@5:A$575 B$=SEG(A$,(I-32*(I>32))*2+7,2)576 CALL "HEXDEC",B$,J577 R(I)=J578 NEXT I579 REM skip 1162 byte header including palette to image start @ 0x048A580 INPUT@5:A$590 B$=SEG(A$,5,4)600 IF B$<>"0480" THEN 580601 REM center the image if smaller than 128x98602 X0=INT(128-W0)*4-1 MAX 0604 Y0=INT(98-H0)*4-1 MAX 0605 X5=X0606 Y5=Y0608 C0=29-2610 FOR Y=1 TO H0 MIN 98620 FOR X=1 TO W0630 C0=C0+2632 IF C0<73 THEN 640634 C0=9636 INPUT@5:A$640 B$=SEG(A$,C0,2)641 CALL "HEXDEC",B$,E642 REM See Tekniques V5N2 pg28 Efficient Array Search - Method B650 T=R=E660 T=T*Q670 I=SUM(T)680 IF I<>0 THEN 740690 PRINT "Grayscale value NOT FOUND"700 END740 H$=CHR(I)741 P0=LEN(P$)+1742 P$=REP(H$,P0,0)745 IF I=1 THEN 760750 GOSUB 2000760 X5=X5+8770 NEXT X780 X5=X0790 Y5=Y5+8800 NEXT Y810 HOME820 END1000 REM R12 Grayscale INIT subroutine 1010 REM Data is for 8x8 dots encoded in 8 bytes, 0,0 org1020 REM skip "1" for blank, every VECTOR in object will get a dot there1025 REM index 1 is blank - no vector dots1030 DATA 2 ,"0000000800000000"1040 DATA 3 ,"0000000402000000"1050 DATA 4 ,"0020000400001000"1060 DATA 5 ,"0008002000044000"1070 DATA 6 ,"0008001042000800"1080 DATA 7 ,"2000044002200800"1090 DATA 8 ,"1000018800100240"1100 DATA 9 ,"4004001081082002"1110 DATA 10,"0208801104400210"1120 DATA 11,"1084104401104004"1130 DATA 12,"08400A2005900210"1140 DATA 13,"2004811442084208"1150 DATA 14,"0844114410441280"1160 DATA 15,"042052240A249001"1170 DATA 16,"01A8022452210A40"1180 DATA 17,"2108822C52240A40"1190 DATA 18,"84102A4429942802"1200 DATA 19,"84500A54A2540920"1210 DATA 20,"210A542A94294410"1220 DATA 21,"88442A44AA542841"1230 DATA 22,"218A502A442A5489"1240 DATA 23,"845229542A54A904"1250 DATA 24,"842A55A2542A5481"1260 DATA 25,"81542A54AA552A84"1270 DATA 26,"842A55AA542A5588"1280 DATA 27,"22552A55AA552A44"1290 DATA 28,"942A55AA55AA5422"1300 DATA 29,"2954AA55AA552A51"1310 DATA 30,"542555AA552A55AA"1320 DATA 31,"AA54AA55AA54AA55"1330 DATA 32,"55AA55AA55AA552A"1340 DATA 33,"AA55AA55AA55AA55"1350 DATA 34,"55AA55AA55BA55AA"1360 DATA 35,"AA55AA75AA57AA55"1370 DATA 36,"55AA5DAA75AA57AA"1380 DATA 37,"AA55BA57AA75AE55"1390 DATA 38,"55EA57AA5DAA77AA"1400 DATA 39,"AA55EE55EE55EE55"1410 DATA 40,"55EE55EE5DAA77AA"1420 DATA 41,"AA77AA7FBA77AA55"1430 DATA 42,"55EA57FE57FA57AA"1440 DATA 43,"AA7FBA55FE55FE55"1450 DATA 44,"55FA5FFA57FA77AA"1460 DATA 45,"AA5FBA7FEE7FBA55"1470 DATA 46,"55FE5DFE77BE77AA"1480 DATA 47,"AA77FE77BE77FE55"1490 DATA 48,"55FE5DFE7FEE7FAA"1500 DATA 49,"AE77FED7FE77FE55"1510 DATA 50,"55FF5DFE7FEE7FBA"1520 DATA 51,"BA77FEFFBE77FE5D"1530 DATA 52,"55FE77FFFFEE7FBA"1540 DATA 53,"BB77FE7FEE7FFF75"1550 DATA 54,"75FEFDFF7FEEFFAE"1560 DATA 55,"BA7FFFF7BEFFFE77"1570 DATA 56,"F5FE5FFFFFEEFFBE"1580 DATA 57,"EE7FFFFFBE77FFF7"1590 DATA 58,"7FFEF7FF7DEFFFBF"1600 DATA 59,"FBF7FEFFBFF7FF7F"1610 DATA 60,"FFFFDDFF77FFFFFE"1620 DATA 61,"FFFFFFF7BEF7FFFF"1630 DATA 62,"FFFFDDFFFFEFFFFF"1640 DATA 63,"FFF7FFFFFFF7FFFF"1650 DATA 64,"FFFFFFEFFFFFFFFF"1660 REM each bit=1 is a dot. G$ contains 1 CHR per XY DOT ASC(X*16+Y)1661 REM each 8x8 grayscale set of dots is same# dots as grayscale index1665 DIM G$(2016),H$(1),P(64),Q(64),R(64),T(64)1666 G$=""1667 Q(1)=11668 P(1)=11669 PRINT "Initializing 64 8x8 R12 grayscale dot patterns"1670 FOR I=2 TO 641672 P(I)=P(I-1)+I-11675 C=01676 Q(I)=I1677 READ I0,B$1680 FOR Y=0 TO 71690 A$=SEG(B$,Y*2+1,2)1700 CALL"HEXDEC",A$,V91720 FOR X9=1 TO 81730 U=FNB(X9)1740 IF U=0 THEN 17801745 C=C+11750 X8=X9-11760 H$=CHR(X8*16+Y)1765 G8=LEN(G$)1770 G$=REP(H$,G8+1,0)1780 NEXT X91790 NEXT Y1795 print ".";1820 NEXT I1830 RETURN2000 REM display grayscale 8x8 dots from index I at X5,Y5 with R122010 REM assumes X5,Y5 is indexed at lower left corner of next 8x82030 DELETE D,Z$2040 DIM D((I-1)*2),Z$((I-1)*3)2050 REM G$ has all grayscale ON dots @ P(I-1)+C-1 where C=dot count2060 K=12070 FOR C=1 TO I-12080 H$=SEG(G$,P(I-1)+C-1,1)2090 H=ASC(H$)2100 D(K)=INT(H/16)+X52110 D(K+1)=H-16*INT(H/16)+Y52120 K=K+22130 NEXT C2140 D=D*0.1282150 CALL "CHANGE",D,Z$2220 CALL "RDOTS",Z$,1,0,02230 RETURN 3000 REM 64 grayscale test pattern3005 PRINT "64 Grayscale test patterns"3010 FOR J=0 TO 33015 FOR X=1 TO 163016 IF J=0 AND X=1 THEN 30503020 X5=(X-1)*103030 Y5=20+20*J3035 I=X+J*163040 GOSUB 20003050 NEXT X3055 NEXT J3060 HOME3070 END4000 REM save P$ as R12 BINARY string block for each 'pixel' to file4010 REM get I from P$, compute full R12 string - write Z$ to file4020 PRINT "Save P$ as R12 BitmapInput Bitmap file#: ";4030 INPUT F4035 PAGE4040 FIND @5:F4050 REM use main program W0,H0,X0,Y0,P$4060 DELETE A$,B$,Q,R,T4070 DIM B$(1)4080 X5=X04090 Y5=Y04100 FOR Y=1 TO H0 MIN 984110 FOR X=1 TO W04120 B$=SEG(P$,X+(Y-1)*W0,1)4130 I=ASC(B$)4140 IF I=1 THEN 41704150 GOSUB 20004160 WRITE@5:I,Z$4170 X5=X5+84180 NEXT X4190 X5=X04200 Y5=Y5+84210 NEXT Y4220 WRITE@5:0,"|EOG|"4230 HOME4240 END5000 REM R12 Bitmap Viewer5005 REM each READ contains I and a precomputed R12 dot string5010 REM last READ contains "|EOG|" to stop viewer5020 PRINT "R12 Bitmap ViewerInput Bitmap file#: ";5030 INPUT F5040 FIND @5:F5050 PAGE5060 READ@5:I5070 DELETE Z$5075 IF I=0 THEN 51205080 DIM Z$((I-1)*3)5090 READ@5:Z$5095 IF I<2 THEN 50605100 CALL "RDOTS",Z$,1,0,05110 GO TO 50605120 DIM Z$(5)5130 READ@5:Z$5140 IF Z$="|EOG|" THEN 51605150 PRINT "Error not |EOG|"5160 HOME5170 END