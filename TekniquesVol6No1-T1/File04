5000 REM*R Cleanup(::)
5010 SET NOKEY 
5020 CLOSE 
5030 KILL "@C49074909#"
5040 IF C2=2 THEN 5062
5050 P$="IDENTIFY"
5060 GOSUB 100
5062 CALL "time",S$
5064 P$="


Listing completed: "&S$
5066 GOSUB 6500
5070 GO TO C2 OF 5080,5100,5120
5080 PRINT "
The transfer";
5090 GO TO 5130
5100 PRINT "
The list";
5110 GO TO 5130
5120 PRINT "
The transfer, list and conversion";
5130 PRINT " operations have been completed.Done."
5140 PRINT @32,26:0
5150 DELETE ALL 
5160 END 
5500 REM*R Get_File_Size(::P0)
5510 CALL "File",F1,F$,T$
5520 T$=SEG(T$,83,9)
5530 P0=VAL(T$)
5540 RETURN 
6000 REM*R Get_File_Type(::P0)
6010 REM Type= 1{Host Bin} 2{ASCII Seq} 3{Bin Seq} 4{ASCII RA} 5{Bin RA}
6020 CALL "file",F1,F$,T$
6030 S$=SEG(T$,6,1)
6040 P0=POS("HAB",S$,1)+2*(POS(T$,"  0",151)<>151)
6050 RETURN 
6500 REM*R Print_To_Printer(P$::)
6510 IF L=32 THEN 6690
6520 C7=0
6530 D6=0
6540 D6=D6+1
6550 C7=POS(P$,"
",C7+1)
6560 IF C7>0 THEN 6540
6570 IF L2+D6<58 THEN 6680
6580 PRINT @L: USING "fa,64t,fa,4d,/":"","Page ",L3
6590 L3=L3+1
6600 IF L3>2 THEN 6670
6610 PRINT @L: USING "21t,fa":"4907 to 4909 File Transfer and"
6620 PRINT @L: USING "23t,fa":"Program Conversion Utility"
6650 L2=2
6660 GO TO 6680
6670 L2=0
6680 L2=L2+D6
6690 PRINT @L:P$
6700 RETURN 
7000 REM*R Read_Byte(P0::P1)
7005 P1=0
7007 IF P0<1 THEN 7110
7010 E6=P0
7020 FOR D7=1 TO 4
7030 E7(D7)=INT(E6/256^(4-D7))
7040 E6=E6-E7(D7)*256^(4-D7)
7050 NEXT D7
7060 E7(4)=-E7(4)-0.1
7065 PRINT "";
7066 WBYTE @63,95,H+32,4,63,95:
7070 WBYTE @32:129,1,E7
7080 WBYTE @64:
7090 RBYTE P1
7100 WBYTE @95:
7110 RETURN 
7500 REM*R Binary_To_Decimal(::P0)
7510 P0=256*(256*B0(1)+B0(2))+B0(3)
7520 RETURN 
10000 REM*R Transfer_Stream(::)
10010 GOSUB 13000
10020 GOSUB 13500
10021 IF RND(0)>0.2 THEN 10030
10022 GOSUB 10300
10024 GO TO 10200
10030 PRINT @H:"WRITE LFN: ";H1
10035 WBYTE @32+H:64
10040 ON EOI THEN 10230
10045 WBYTE @63,95:
10050 WBYTE @32:129,1,0,0,0,-0.1
10060 WBYTE %63,95,32+H,64:
10070 REM 4907 talking directly to listening 4909
10080 WAIT 
10090 WBYTE @95:
10100 OFF EOI 
10102 INPUT @H:M$
10103 WBYTE @63,95,H+32,4,63,95:
10104 IF M$="@
" OR M$="EOT
" THEN 10110
10106 PRINT "Bad data transmission in Transfer_Stream. Fatal Error."
10108 STOP 
10110 GOSUB 5500
10120 P0=P0-1
10130 GOSUB 7000
10140 P0=ABS(P1)*(P1<>-256)
10150 GOSUB 14000
10160 P$=STR(H1)
10170 P$=REP("WRITE LFN:",1,1)
10180 P$=P$&" POSITION:ATEND"
10190 GOSUB 14500
10200 GOSUB 15000
10210 GOSUB 15500
10220 RETURN 
10230 REM*R Eoi_Return(::)
10235 WBYTE @63,95:
10240 RETURN 
10300 REM*R Transfer 4051 files
10310 U0=0
10320 N0=0
10325 D9=0
10330 C$=STR(H1)
10332 C$="WRITE LFN:"&C$
10334 C$=C$&" POS:ATEND"
10340 GOSUB 17500
10350 IF N0(N1)<>-255 THEN 10380
10360 D9=1
10380 U0=N0
10390 U2=N1-D9
10400 GOSUB 19000
10410 IF NOT(D9) THEN 10340
10415 C$=""
10420 RETURN 
10500 REM*R Transfer_Binary_Sequential(::)
10510 GOSUB 13000
10520 GOSUB 13500
10530 P$=STR(H1)
10540 P$="WRITE LFN:"&P$
10550 GOSUB 14500
10560 GOSUB 16000
10570 S6=P0
10580 IF S6=-255 THEN 10680
10590 REM WHILE NOT(EOF)
10600 P0=P1
10610 GOSUB S6-5 OF 12000,12500
10620 IF S6=6 OR S6=7 THEN 10640
10630 GOSUB 16500
10640 GOSUB 16000
10650 S6=P0
10660 REM ENDWHILE
10670 GO TO 10580
10680 GOSUB 15000
10690 GOSUB 15500
10700 RETURN 
11000 REM*R Transfer_Ascii_Random_Access(::)
11010 GOSUB 13000
11020 GOSUB 13500
11030 Q7=0
11040 CALL "file",F1,F$,T$
11050 T$=SEG(T$,145,9)
11060 Q6=VAL(T$)
11070 GOSUB 17000
11080 IF P0=-255 THEN 11270
11090 REM WHILE NOT(EOF)
11100 Q7=Q7+1
11110 P$=STR(H1)
11120 P$="WRITE LFN:"&P$
11130 S$=STR(Q7)
11140 S$=" INDEX:"&S$
11150 P$=P$&S$
11160 GOSUB 14500
11170 S7=1
11180 IF S7>Q6 OR P0=-255 THEN 11260
11190 REM      WHILE Position<=Record_Length AND NOT(EOF)
11200 GOSUB 14000
11210 S7=S7+1
11220 GOSUB 17000
11230 REM      ENDWHILE
11240 GO TO 11180
11250 REM ENDWHILE
11260 GO TO 11080
11270 GOSUB 15000
11280 GOSUB 15500
11290 RETURN 
11500 REM*R Transfer_Binary_Random_Access(::)
11510 GOSUB 13000
11520 GOSUB 13500
11530 R7=0
11540 GOSUB 16000
11550 R6=P0
11560 IF R6=-255 THEN 11800
11570 REM WHILE NOT(EOF)
11580 R7=R7+1
11590 P$=STR(H1)
11600 P$="WRITE LFN:"&P$
11610 S$=STR(R7)
11620 S$=" INDEX:"&S$
11630 P$=P$&S$
11640 GOSUB 14500
11650 IF R6=20 OR R6=-255 THEN 11750
11660 REM      WHILE NOT(EOF) AND NOT(EOR)
11670 P0=P1
11680 GOSUB R6-5 OF 12000,12500
11690 IF R6=6 OR R6=7 THEN 11710
11700 GOSUB 16500
11710 GOSUB 16000
11720 R6=P0
11730 REM      ENDWHILE
11740 GO TO 11650
11750 IF R6=-255 THEN 11800
11760 GOSUB 16000
11770 R6=P0
11780 REM ENDWHILE
11790 GO TO 11560
11800 GOSUB 15000
11810 GOSUB 15500
11820 RETURN 
12000 REM*R Transfer_Binary_Number(::)
12010 P0=6
12020 GOSUB 14000
12030 GOSUB 17000
12040 O7=16*(P0-16*INT(P0/16))
12050 P0=INT(P0/16)
12060 REM Transform number by shifting right 4 bits. Maintain sign bit.
12070 P0=P0+(P0=>8)*120
12080 GOSUB 14000
12090 FOR N7=2 TO 8
12100 GOSUB 17000
12110 O6=P0
12120 P0=INT(P0/16)+O7
12130 GOSUB 14000
12140 O7=16*(O6-16*INT(O6/16))
12150 NEXT N7
12160 RETURN 
12500 REM*R Transfer_Binary_String(P0::)
12510 M6=P0
12520 P0=7
12530 GOSUB 14000
12540 FOR M7=1 TO 3
12550 P0=B0(M7)
12560 GOSUB 14000
12570 NEXT M7
12580 IF M6<=0 THEN 12630
12590 FOR M7=1 TO M6
12600 GOSUB 17000
12610 GOSUB 14000
12620 NEXT M7
12630 RETURN 
13000 REM*R Open_4907(::)
13010 N3=0
13020 F0=0
13030 F0(4)=-0.1
13035 CLOSE 1
13040 OPEN F$;1,"R",S$
13050 RETURN 
13500 REM*R Open_4909(::)
13510 C$=""
13520 U2=0
13530 P$=STR(H1)
13540 P$=" LFN:"&P$
13550 P$=H$&P$
13560 P$="OPEN "&P$
13570 GOSUB 100
13580 RETURN 
14000 REM*R Write_Data(P0::)
14010 N6=P0
14020 IF U2<U1 THEN 14060
14030 GOSUB 19000
14040 IF POS(C$,"POSITION:ATEND",1)>0 THEN 14060
14050 C$=C$&" POSITION:ATEND"
14060 U2=U2+1
14070 U0(U2)=N6
14080 RETURN 
14500 REM*R Write_Command(P$::)
14510 IF C$="" THEN 14530
14520 GOSUB 19000
14530 C$=P$
14540 RETURN 
15000 REM*R Close_4907(::)
15010 CLOSE 1
15020 RETURN 
15500 REM*R Close_4909(::)
15510 GOSUB 19000
15520 P$=STR(H1)
15530 P$="CLOSE LFN:"&P$
15540 GOSUB 100
15550 RETURN 
16000 REM*R Find_Next_Valid_Data_Item(::P0,P1)
16010 GOSUB 17000
16020 GOSUB 18000
16030 IF P0=6 OR P0=7 OR P0=20 OR P0=-255 THEN 16110
16040 REM WHILE Type is not valid
16050 P0=P1
16060 GOSUB 16500
16070 GOSUB 17000
16080 GOSUB 18000
16090 GO TO 16030
16100 REM ENDWHILE
16110 RETURN 
16500 REM*R Bypass(P0::)
16510 IF P0<=0 THEN 16560
16520 FOR B6=1 TO P0
16530 GOSUB 17000
16540 REM Get_Next_Byte and discard
16550 NEXT B6
16560 RETURN 
17000 REM*R Get_Next_Byte(::P0)
17010 IF N3<>0 THEN 17040
17020 GOSUB 17500
17030 N3=1
17040 P0=N0(N3)
17050 N3=(N3+1)*(N3<N1)
17060 RETURN 
17500 REM*R Fill_Input_Buffer(::)
17510 I6=0
17520 N1=0
17525 PRINT "";
17530 WBYTE @32:129,1,F0
17540 WBYTE @64:
17550 IF I6<0 OR N1=>N2-1 THEN 17620
17560 REM WHILE NOT(EOI) AND Input_Buffer_Len<Input_Buffer_Max_Len -1
17570 RBYTE I6
17580 N1=N1+1
17590 N0(N1)=ABS(I6)*(I6<>-256)
17600 REM ENDWHILE
17610 GO TO 17550
17620 WBYTE @95:
17630 IF I6<0 THEN 17720
17640 REM Buffer filled prior to EOF. Save file pointer
17650 WBYTE @32:133,-1
17660 WBYTE @64:
17670 RBYTE F0
17680 WBYTE @95:
17690 F0(4)=F0(4)*(F0(4)<>-256)-0.1*(F0(4)=-256)
17700 GO TO 17740
17710 REM EOF
17720 N1=N1+1
17730 N0(N1)=-255
17740 RETURN 
18000 REM*R Get_Length(P0::P1)
18010 B0=0
18020 P1=0
18030 IF P0>21 THEN 18090
18040 GO TO (P0<1)+(P0=-255) OF 18190,18210
18050 S$=SEG("132448~~~??????012~00",P0,1)
18060 GO TO (S$="~")+2*(S$="?") OF 18100,18190
18070 P1=VAL(S$)
18080 GO TO 18210
18090 IF P0<30 OR (P0>31 AND P0<80) OR P0>254 THEN 18190
18100 L7=P0
18110 FOR L6=1 TO 3
18120 GOSUB 17000
18130 B0(L6)=P0
18140 NEXT L6
18150 GOSUB 7500
18160 P1=P0+(L7=31)+4*(L7=30)
18170 P0=L7
18180 GO TO 18210
18190 PRINT "unknown data type input to Get_Length"
18200 STOP 
18210 RETURN 
19000 REM*R Flush_Buffer(::)
19010 IF C$="" OR U2<=0 THEN 19100
19020 PRINT @H:C$
19030 WBYTE @32+H:64
19040 DIM U0(U2)
19050 WBYTE U0
19060 DIM U0(U1)
19070 WBYTE -10
19080 WBYTE @63:
19082 INPUT @H:M$
19083 WBYTE @63,95,H+32,4,63,95:
19084 IF M$="@
" OR M$="EOT
" THEN 19090
19086 PRINT "Bad data transmission in Flush_Buffer. Fatal error."
19088 STOP 
19090 GO TO 19130
19100 IF C$="" AND U2<=0 THEN 19130
19110 PRINT "Unexpected call to Flush_Buffer. Fatal error."
19120 STOP 
19130 U2=0
19140 RETURN 
30000 REM*R List/Convert_ASCII_File(::)
30010 B3=0
30020 CLOSE 1
30030 OPEN F$;1,"R",T$
30040 PRINT "";
30050 IF C2<>3 THEN 30120
30060 GOSUB 5500
30070 CLOSE 2
30080 KILL "@C49074909/TEMP2"
30090 CREATE "@C49074909/TEMP2","A";P0+0,0
30100 OPEN "@C49074909/TEMP2";2,"F",T$
30110 PRINT "";
30120 B1=0
30130 ON EOF (1) THEN 46000
30140 P9=0
30150 INPUT #1:L$
30160 IF B1 OR P9 THEN 30220
30170 IF L$="" THEN 30190
30180 GOSUB 31000
30190 IF C2<>3 OR P9 THEN 30210
30200 PRINT #2:L$
30210 GO TO 30150
30220 IF NOT(P9 AND (B3 OR C2=2)) THEN 30270
30230 P$="
**** Conversion skipped: "
30240 P$=P$&"This file is not a BASIC program. ****"
30245 IF C2<>2 THEN 30260
30250 P$=REP("Listing",7,10)
30260 GOSUB 6500
30270 CLOSE 1
30280 CLOSE 2
30290 IF C2<>3 OR P9 THEN 30310
30300 F$="@C49074909/TEMP2"
30310 OFF EOF (1)
30320 RETURN 
31000 REM*R Convert_And_List_1_Line(::P9)
31010 GOSUB 32000
31020 IF P9 THEN 31040
31030 GOSUB 36000
31040 RETURN 
32000 REM*R Parse_Line_Start(::P0,P9)
32010 IF LEN(L$)<=72 THEN 32040
32020 P9=1
32030 GO TO 32090
32040 GOSUB 33000
32050 IF P9 THEN 32090
32060 GOSUB 34000
32070 IF P9 THEN 32090
32080 GOSUB 35000
32090 RETURN 
33000 REM*R Extract_Line_Number(::P9)
33010 P9=1
33020 L1=POS(L$," ",1)
33030 IF L1<=1 OR L1=>7 THEN 33090
33040 K$=SEG(L$,1,L1-1)
33050 T$=K$&" -1"
33060 L8=VAL(T$)
33070 IF L8<1 OR L8>65535 OR INT(L8)<>L8 THEN 33090
33080 P9=0
33090 RETURN 
34000 REM*R Extract_Keyword(::P$,P9)
34010 P9=1
34020 IF L1+3>LEN(L$) THEN 34120
34030 L8=L1
34040 L8=L8+1
34050 S$=SEG(L$,L8,1)
34060 IF POS("ABCDEFGHIJKLMNOPQRSTUVWXYZ",S$,1)>0 AND S$<>"" THEN 34040
34070 P$=SEG(L$,L1+1,L8-L1-1)
34080 IF LEN(P$)<1 OR LEN(P$)>10 THEN 34120
34090 L1=L8
34100 P$=SEG(P$,1,3)
34110 P9=0
34120 RETURN 
35000 REM*R Determine_Keyword_Type(P$::P0,P9)
35010 IF P$<>"CAL" THEN 35070
35020 GOSUB 43000
35030 IF P9 THEN 35230
35040 S$=SEG(L$,P0,1)
35050 IF S$<>"""" THEN 35070
35060 P$=SEG(L$,P0,L1-P0-1)
35070 RESTORE 35080
35080 DATA "APP","ASS","""COMPRS""","COP","CRE","""CUSTAT"""
35090 DATA "DIR","""DISMOUNT""","""DREL""","""DRES"""
35100 DATA """DSTAT""","""DUP""","""FFRMT""","""FILE"""
35110 DATA """FMVALS""","""FORMAT""","""HERRS""","KIL"
35120 DATA """MOUNT""","""MRKBBG""","""NEXT""","OLD"
35130 DATA "OPE","""RENAME""","""REWIND""","SAV","""SPACE"""
35140 DATA "UNI","""UNIT""","""USERLIB"""
35150 DATA " "
35160 P0=1
35170 READ S$
35180 IF S$=" " THEN 35220
35190 IF S$=P$ THEN 35230
35200 P0=P0+1
35210 GO TO 35170
35220 P0=0
35230 RETURN 
36000 REM*R Convert_By_Keyword_Type(P0::P9)
36003 K8=P0
36006 IF K8<1 THEN 36717
36009 GOSUB 37000
36012 IF P9 THEN 36720
36015 GO TO K8 OF 36036,36066,36084,36102,36126
36018 GO TO K8-5 OF 36144,36165,36240,36258,36276
36021 GO TO K8-10 OF 36294,36315,36336,36360,36381
36024 GO TO K8-15 OF 36399,36420,36438,36477,36495
36027 GO TO K8-20 OF 36513,36534,36564,36594,36615
36030 GO TO K8-25 OF 36630,36660,36678,36678,36699
36033 STOP 
36036 REM*B APPend
36039 P0=1
36042 GOSUB 38000
36045 IF NOT(P1) THEN 36063
36048 GOSUB 41000
36051 P$=L$
36054 GOSUB 6500
36057 P0=1
36060 GOSUB 42000
36063 GO TO 36720
36066 REM*B ASSign
36069 GOSUB 41000
36072 GOSUB 40000
36075 P0=2
36078 GOSUB 42000
36081 GO TO 36720
36084 REM*B "COMPRS"
36087 GOSUB 41000
36090 GOSUB 40000
36093 P0=3
36096 GOSUB 42000
36099 GO TO 36720
36102 REM*B "COPY"
36105 IF C1<1 THEN 36123
36108 GOSUB 41000
36111 P$="CALL ""COPY"",""UNIT:"";~2,~1,""TO UNIT:"";~5,~4"
36114 GOSUB 39000
36117 P0=4
36120 GOSUB 42000
36123 GO TO 36720
36126 REM*B CREate
36129 GOSUB 41000
36132 GOSUB 40000
36135 P0=2
36138 GOSUB 42000
36141 GO TO 36720
36144 REM*B "CUSTAT"
36147 GOSUB 41000
36150 P$="CALL ""STATUS"",""UNIT:ALL"",~1"
36153 GOSUB 39000
36156 P0=5
36159 GOSUB 42000
36162 GO TO 36720
36165 REM*B DIRectory
36168 P0=C1
36171 GOSUB 38000
36174 F8=P1
36177 F9=0
36180 IF C1<1 THEN 36201
36183 S$=SEG(L$,C0(1,1),1)
36186 IF S$<>"@" THEN 36201
36189 K8=POS(L$,":",C0(1,1))
36192 P9=K8=0
36195 IF P9 THEN 36720
36198 F9=1
36201 IF NOT(F8) AND NOT(F9) THEN 36237
36204 GOSUB 41000
36207 IF NOT(F9) THEN 36219
36210 L$=REP("",C0(1,1),K8-C0(1,1)+1)
36213 P$=L$
36216 GOSUB 6500
36219 IF NOT(F9) THEN 36228
36222 P0=7
36225 GOSUB 42000
36228 IF NOT(F8) THEN 36237
36231 P0=1
36234 GOSUB 42000
36237 GO TO 36720
36240 REM*B "DISMOUNT"
36243 GOSUB 41000
36246 GOSUB 40000
36249 P0=3
36252 GOSUB 42000
36255 GO TO 36720
36258 REM*B "DREL"
36261 GOSUB 41000
36264 GOSUB 40000
36267 P0=3
36270 GOSUB 42000
36273 GO TO 36720
36276 REM*B "DRES"
36279 GOSUB 41000
36282 GOSUB 40000
36285 P0=3
36288 GOSUB 42000
36291 GO TO 36720
36294 REM*B "DSTAT"
36297 GOSUB 41000
36300 P$="CALL ""STATUS"",""UNIT:"";~1,~2"
36303 GOSUB 39000
36306 P0=5
36309 GOSUB 42000
36312 GO TO 36720
36315 REM*B "DUP"
36318 GOSUB 41000
36321 P$="CALL ""DUPLICATE"",""UNIT:"",~1,""TO UNIT:"";~2"
36324 GOSUB 39000
36327 P0=6
36330 GOSUB 42000
36333 GO TO 36720
36336 REM*B "FFRMT"
36339 GOSUB 41000
36342 P$="CALL ""FORMAT"",""UNIT:"";~1,""NVOL:"";~2,""NMPW:"";~6"
36345 P$=P$&",""FAST"""
36348 GOSUB 39000
36351 P0=5
36354 GOSUB 42000
36357 GO TO 36720
36360 REM*B "FILE"
36363 GOSUB 41000
36366 P$="CALL ""DIRECTORY"",""UNIT:"";~1,~2,~3"
36369 GOSUB 39000
36372 P0=5
36375 GOSUB 42000
36378 GO TO 36720
36381 REM*B "FMVALS"
36384 GOSUB 41000
36387 GOSUB 40000
36390 P0=2
36393 GOSUB 42000
36396 GO TO 36720
36399 REM*B "FORMAT"
36402 GOSUB 41000
36405 P$="CALL ""FORMAT"",""UNIT:"";~1,""NVOL:"";~2,""NMPW:"";~6"
36408 GOSUB 39000
36411 P0=5
36414 GOSUB 42000
36417 GO TO 36720
36420 REM*B "HERRS"
36423 GOSUB 41000
36426 GOSUB 40000
36429 P0=2
36432 GOSUB 42000
36435 GO TO 36720
36438 REM*B KILl
36441 P0=1
36444 GOSUB 38000
36447 IF NOT(P1) THEN 36474
36450 GOSUB 41000
36453 P$="CALL ""DELETE"",~1"
36456 IF C1<2 THEN 36462
36459 P$=P$&",""MPW:"";~2"
36462 P$=P$&",""NINQ"""
36465 GOSUB 39000
36468 P0=1
36471 GOSUB 42000
36474 GO TO 36720
36477 REM*B "MOUNT"
36480 GOSUB 41000
36483 GOSUB 40000
36486 P0=3
36489 GOSUB 42000
36492 GO TO 36720
36495 REM*B "MRKBBG"
36498 GOSUB 41000
36501 GOSUB 40000
36504 P0=2
36507 GOSUB 42000
36510 GO TO 36720
36513 REM*B "NEXT"
36516 GOSUB 41000
36519 P$="CALL ""OPEN"",""LFN:"";~1,""NEXT"""
36522 GOSUB 39000
36525 P0=5
36528 GOSUB 42000
36531 GO TO 36720
36534 REM*B "OLD"
36537 P0=1
36540 GOSUB 38000
36543 IF NOT(P1) THEN 36561
36546 GOSUB 41000
36549 P$=L$
36552 GOSUB 6500
36555 P0=1
36558 GOSUB 42000
36561 GO TO 36720
36564 REM*B OPEn
36567 GOSUB 41000
36570 IF C1<>4 THEN 36579
36573 P$="CALL ""OPEN"",~1,""LFN:"";~2"
36576 GO TO 36582
36579 P$="CALL ""OPEN"",~1,""LFN:"";~3"
36582 GOSUB 39000
36585 P0=5
36588 GOSUB 42000
36591 GO TO 36720
36594 REM*B "RENAME"
36597 GOSUB 41000
36600 P$="CALL ""RENAME"",""UNIT:"";~1,~2,""TO UNIT:"";~1,~3"
36603 GOSUB 39000
36606 P0=4
36609 GOSUB 42000
36612 GO TO 36720
36615 REM*B "REWIND"
36618 GOSUB 41000
36621 P$="CALL ""RLOCATE"",~1,""POSITION:0"""
36624 GOSUB 39000
36627 GO TO 36720
36630 REM*B SAVe
36633 P0=1
36636 GOSUB 38000
36639 IF NOT(P1) THEN 36657
36642 GOSUB 41000
36645 P$=L$
36648 GOSUB 6500
36651 P0=1
36654 GOSUB 42000
36657 GO TO 36720
36660 REM*B "SPACE"
36663 GOSUB 41000
36666 GOSUB 40000
36669 P0=3
36672 GOSUB 42000
36675 GO TO 36720
36678 REM*B UNIt and "UNIT"
36681 GOSUB 41000
36684 P$="CALL ""IDENTIFY"",""UNIT:"";~1"
36687 GOSUB 39000
36690 P0=5
36693 GOSUB 42000
36696 GO TO 36720
36699 REM*B "USERLIB"
36702 GOSUB 41000
36705 GOSUB 40000
36708 P0=2
36711 GOSUB 42000
36714 GO TO 36720
36717 P9=0
36720 RETURN 
37000 REM*R Build_Chunk_List(::P9)
37010 C1=0
37020 P9=0
37030 IF L1>LEN(L$) OR P9 THEN 37130
37040 GOSUB 43000
37050 IF P9 THEN 37120
37052 L9=L1-P0-1
37054 IF L9=0 THEN 37120
37060 C1=C1+1
37070 IF C1<12 THEN 37100
37080 P9=1
37090 GO TO 37120
37100 C0(C1,1)=P0
37110 C0(C1,2)=L9
37120 GO TO 37030
37130 RETURN 
38000 REM*R Determine_If_Chunk_Is_String(P0::P1)
38010 P1=0
38020 IF P0>C1 OR P0<1 THEN 38090
38030 S$=SEG(L$,C0(P0,1),1)
38040 IF S$<>"""" THEN 38060
38050 GO TO 38080
38060 S$=SEG(L$,C0(P0,1)+C0(P0,2)-1,1)
38070 IF S$<>"$" THEN 38090
38080 P1=1
38090 RETURN 
39000 REM*R Convert_Using_Template(P$::)
39010 T$=K$&" "
39020 I8=1
39030 S$=SEG(P$,I8,1)
39040 IF S$="" THEN 39160
39050 IF S$<>"~" THEN 39130
39060 I8=I8+1
39070 S$=SEG(P$,I8,1)
39080 C8=VAL(S$)
39090 IF C8>C1 THEN 39104
39100 S$=SEG(L$,C0(C8,1),C0(C8,2))
39102 IF S$<>"" THEN 39110
39104 S$="""Missing parameter"""
39110 T$=T$&S$
39120 GO TO 39140
39130 T$=T$&S$
39140 I8=I8+1
39150 GO TO 39030
39160 L$=T$
39170 IF LEN(L$)<73 THEN 39200
39180 GOSUB 40000
39190 GO TO 39230
39200 P$=L$
39210 GOSUB 6500
39220 B3=1
39230 RETURN 
40000 REM*R Convert_To_REM(::)
40010 L8=POS(L$," ",1)
40020 L$=REP("REM --> ",L8+1,0)
40030 IF LEN(L$)<73 THEN 40050
40040 L$=REP("....",69,LEN(L$)-68)
40050 P$=L$
40060 GOSUB 6500
40062 IF POS(L$,"....",69)<>69 THEN 40070
40064 P$="Warning: The converted line was too long and was truncated."
40066 GOSUB 6500
40070 B3=1
40080 RETURN 
41000 REM*R Echo_4907_Line(::)
41010 P$="
"&L$
41020 GOSUB 6500
41030 B3=1
41040 RETURN 
42000 REM*R Print_Warning(P0::)
42010 GO TO P0 OF 42030,42060,42090,42110,42140,42160,42174
42020 STOP 
42030 P$="Warning: The file identifier should be checked for 4909"
42040 P$=P$&" compatibility."
42050 GO TO 42180
42060 P$="Problem: Automatic conversion is not possible for this"
42070 P$=P$&" statement."
42080 GO TO 42180
42090 P$="Note: This statement is not needed on the 4909."
42100 GO TO 42180
42110 P$="Warning: Check the file id's and unit #'s for 4909"
42120 P$=P$&" compatibility."
42130 GO TO 42180
42140 P$="Warning: This is only an approximate translation."
42150 GO TO 42180
42160 P$="Warning: The unit numbers should be checked for 4909"
42170 P$=P$&" compatibility."
42172 GO TO 42180
42174 P$="Warning: I/O addresses cannot be used in 4909 DIRECTORY"
42176 P$=P$&" commands."
42180 GOSUB 6500
42190 RETURN 
43000 REM*R Get_Next_Chunk(::P0,P9)
43010 S$=SEG(L$,L1,1)
43020 IF S$<>" " THEN 43050
43030 L1=L1+1
43040 GO TO 43010
43050 P9=0
43060 P0=L1
43070 S$=SEG(L$,L1,1)
43080 IF POS(" ,;:",S$,1)>0 OR P9 THEN 43160
43090 L1=L1+1
43100 IF S$<>"""" THEN 43130
43110 GOSUB 45000
43120 GO TO 43150
43130 IF S$<>"(" THEN 43150
43140 GOSUB 44000
43150 GO TO 43070
43160 L1=L1+1 MIN LEN(L$)+2
43170 RETURN 
44000 REM*R Get_Parenthesized_Chunk(::P9)
44010 P9=0
44020 S$=SEG(L$,L1,1)
44030 IF S$=")" OR L1=>LEN(L$) OR P9 THEN 44120
44040 L1=L1+1
44050 IF S$<>"""" THEN 44080
44060 GOSUB 45000
44070 GO TO 44100
44080 IF S$<>"(" THEN 44100
44090 GOSUB 44000
44100 GO TO 44020
44110 L1=L1+1
44120 IF S$=")" THEN 44140
44130 P9=1
44140 RETURN 
45000 REM*R Get_String_Chunk(::p9)
45010 S$=SEG(L$,L1,1)
45020 T$=SEG(L$,L1+1,1)
45030 IF NOT(S$<>"""" OR T$="""" AND L1<LEN(L$)) THEN 45060
45040 L1=L1+1
45050 GO TO 45010
45060 P9=S$<>""""
45070 L1=L1+1
45080 RETURN 
46000 REM*R EOF_Trap(::)
46010 B1=1
46020 RETURN 
47000 REM*R Check_HB_Conversion(::P9)
47010 GOSUB 5500
47020 CLOSE 1
47025 OPEN F$;1,"R",T$
47030 F8=P0
47040 A8=F8-5
47045 IF A8<0 THEN 47230
47050 P0=A8+1
47060 GOSUB 7000
47070 L8=P1
47080 P0=A8
47090 GOSUB 7000
47100 S8=P1
47110 IF S8=128 OR S8=129 OR A8+L8+3=F8 OR A8=0 THEN 47150
47120 A8=A8-1
47125 IF A8<0 THEN 47230
47130 L8=S8
47140 GO TO 47080
47150 P0=A8+2
47160 GOSUB 7000
47170 L8=P1
47180 P0=A8+3
47190 GOSUB 7000
47200 IF L8*256+P1=>65000 THEN 47230
47220 IF F8*1.4*1.25<MEMORY+20*1024 THEN 47250
47230 P9=1
47240 GO TO 47260
47250 P9=0
47260 CLOSE 1
47270 RETURN 

