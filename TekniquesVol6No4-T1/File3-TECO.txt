1 REM TECO w/disk & numeric Q reg -- 11/24/82          (file 3)
2 GO TO 200
4 PRINT "press c/r to start assembler: ";
5 INPUT A$
6 OLD "assem"
8 PRINT "*** restart ***"
9 GO TO 420
40 PRINT "saving on file  ""TECO"""
41 SAVE "TECO"
42 PRINT "done"
43 RETURN 
80 RENUMBER 80,2,80
82 RENUMBER 200,10,200
84 RENUMBER 1000,10,1000
86 RENUMBER 2000,10,2000
88 RENUMBER 3000,10,3000
90 RENUMBER 4000,10,4000
92 RENUMBER 4500,10,4500
94 RENUMBER 5000,10,5000
96 RENUMBER 10000,10,10000
98 RENUMBER 11000,10,11000
100 RENUMBER 12000,10,12000
102 RENUMBER 13000,10,13000
104 RENUMBER 14000,10,14000
106 RENUMBER 15000,10,15000
108 RENUMBER 16000,10,16000
110 RENUMBER 17000,10,17000
112 RENUMBER 18000,10,18000
114 PRINT "RENUMBER COMPLETE"
116 END 
200 REM INITIALIZE AND MAIN LOOP
210 INIT 
220 DIM Bracket(10),Q_reg(36),Macros$(500)
230 DIM Cmd$(500),Last_cmd$(500),Arg$(500),Text$(MEMORY-5000)
240 Q_reg=0
250 Cmd$=""
260 Last_cmd$=""
270 Text$=""
280 _trace=0  !set to 1 for debug output
290 DIM Cr$(1),Esc$(1),Opr$(1),Eom$(1)
300 Cr$=CHR(13)  ! carriage return
310 Esc$=CHR(27)  ! escape
320 Eom$=CHR(127)  ! end of macro
330 Macros$=Eom$
340 FOR I=ASC("0") TO ASC("Z")
350 IF I<ASC(":") OR I>ASC("@") THEN 
360 Macros$=Macros$&CHR(I)&Eom$
370 END IF 
380 NEXT I
390 _dot=1  ! text pointer
400 Undef=1.0E+300  ! undefined value
410 Last_search$=""
420 REM MAIN LOOP
430 FOR Cmd_no=0 TO 1.0E+10
440 Last_cmd$=Cmd$
450 CALL Get_cmd(Cmd$)
460 CALL Exe_cmd(Cmd$)
470 NEXT Cmd_no
480 END 
1000 SUB Get_char(A$)
1010 LOCAL X,Y
1020 DO 
1030 CCINPUT A$
1040 EXIT IF LEN(A$)
1050 GIN X,Y
1060 PRINT @32,24:"?"
1070 LOOP 
1080 IF ASC(A$)>128 AND ASC(A$)<150 THE   ! high parity for certain keys
1090 A$=CHR(ASC(A$)-128)
1100 END IF 
1110 IF ASC(A$)=127 THEN 
1120 PRINT "HIX";
1130 ELSE 
1140 CALL Pr_asc(ASC(A$))
1150 END IF 
1160 END SUB 
2000 SUB Get_cmd(Cmd$)
2010 CALL Pr_string("*")
2020 Cmd$=""
2030 DO 
2040 CALL Get_char(A$)
2050 Cmd$=Cmd$&A$
2060 Last2$=SEG(Cmd$,LEN(Cmd$)-1,2)
2070 Last1=ASC(Cmd$,LEN(Cmd$))
2080 IF Last1=127 THEN 
2090 Cmd$=SEG(Cmd$,1,LEN(Cmd$)-2)
2100 ELSE 
2110 IF Last2$="" THEN 
2120 Last_cmd$=SEG(Cmd$,1,LEN(Cmd$)-2)
2130 Cmd$=""
2140 CALL Pr_string(Cr$)
2150 CALL Pr_string("*")
2160 ELSE 
2170 IF Last2$=" " THEN 
2180 CALL Pr_string(Cr$)
2190 Cmd$=SEG(Cmd$,1,LEN(Cmd$)-2)
2200 CALL Pr_string(Cmd$)
2210 ELSE 
2220 IF Last2$="" THEN 
2230 Cmd$=SEG(Cmd$,1,LEN(Cmd$)-1)
2240 END IF 
2250 END IF 
2260 END IF 
2270 END IF 
2280 EXIT IF Last2$=""
2290 LOOP 
2300 CALL Pr_string(Cr$)
2310 END SUB 
3000 SUB Pr_string(A$)
3010 CALL Pr_substr(A$,1,LEN(A$))
3020 END SUB 
3030 SUB Pr_substr(A$,I1,I2)
3040 LOCAL I,C,Sr$,Ss
3050 IF I2=>I1 AND I2<=LEN(A$) THEN 
3060 Sr$="
"&CHR(127)&CHR(255)
3070 Ss=SEARCH(A$,Sr$,I1)
3080 IF Ss>0 AND Ss<=I2 THEN 
3090 FOR I=I1 TO I2
3100 IF I MOD 72 THEN 
3110 CALL Abort
3120 END IF 
3130 CALL Pr_asc(ASC(A$,I))
3140 NEXT I
3150 ELSE 
3160 CALL Lit_str(A$,I1,I2)
3170 END IF 
3180 END IF 
3190 END SUB 
3200 SUB Lit_str(A$,I1,I2)
3210 LOCAL Li,Sr$
3220 FOR Li=I1 TO I2 STEP 72
3230 CALL Abort
3240 Sr$=SEG(A$,Li,72 MIN I2-Li+1)
3250 PRINT Sr$;
3260 NEXT Li
3270 END SUB 
3280 SUB Pr_asc(C)
3290 IF C>127 THEN 
3300 LOCAL X,Y
3310 GIN X,Y
3320 C=C-128
3330 CALL Pr_asc(C+0)
3340 MOVE X+0.3,Y
3350 END IF 
3360 IF C<32 AND C<>13 AND C<>27 AND C<>9 THEN 
3370 PRINT "^";
3380 C=C+64
3390 END IF 
3400 IF C=27 THEN 
3410 PRINT "<>";
3420 ELSE 
3430 C$=CHR(C)
3440 PRINT C$;
3450 END IF 
3460 END SUB 
3470 SUB Abort
3480 LOCAL C$
3490 DIM C$(1)
3500 CCINPUT C$
3510 IF LEN(C$) THEN 
3520 CALL Err("aborted")
3530 END IF 
3540 END SUB 
4000 SUB Exe_cmd(Cmd$)
4010 IF _trace THEN 
4020 PRINT "cmd$=";Cmd$
4030 PRINT "last_cmd$=";Last_cmd$
4040 END IF 
4050 Pc=1
4060 Arg1=Undef
4070 Arg2=Undef
4080 Opr$=""
4090 Bracket_count=0
4100 DO 
4110 CALL Abort
4120 CALL Ch
4130 IF _trace THEN 
4140 PRINT "ch=""";Ch$;""",";Ch  ! debug
4150 END IF 
4160 EXIT IF Ch$=""
4170 Ch8=(Ch MOD 8)+1
4180 GO TO INT(Ch/8)+1 OF 4510,4540,4570,4600,4630,4660,4690,4720
4190 GO TO INT(Ch/8)-7 OF 4750,4780,4810,4840,4870,4900,4930,4960
4200 CALL Err("illegal command")
4500 REM            ^@   ^a   ^b   ^c   ^d   ^e   ^f   ^g
4510 GOSUB Ch8 OF 4200,5010,4200,4200,4200,4200,4200,4200
4520 GO TO 4970
4530 REM            ^h   ^i   ^j   ^k   ^l   ^m   ^n   ^o
4540 GOSUB Ch8 OF 4200,4200,4200,4200,4200,4200,4200,4200
4550 GO TO 4970
4560 REM            ^p   ^q   ^r   ^s   ^t   ^u   ^v   ^w
4570 GOSUB Ch8 OF 4200,4200,4200,4200,4200,4200,4200,4200
4580 GO TO 4970
4590 REM            ^x   ^y   ^z   ^[   ^\   ^]   ^^   ^_
4600 GOSUB Ch8 OF 4200,4200,4200,5090,4200,4200,4200,4200
4610 GO TO 4970
4620 REM           sp    !    "    #    $    %    &    '
4630 GOSUB Ch8 OF 4200,4200,4200,4200,4200,4200,4200,4200
4640 GO TO 4970
4650 REM            (    )    *    +    ,    -    .    /
4660 GOSUB Ch8 OF 4200,4200,5230,5300,5140,5330,5400,5370
4670 GO TO 4970
4680 REM            0    1    2    3    4    5    6    7
4690 GOSUB Ch8 OF 5430,5430,5430,5430,5430,5430,5430,5430
4700 GO TO 4970
4710 REM            8    9    :    ;    <    =    >    ?
4720 GOSUB Ch8 OF 5430,5430,5480,4200,5570,5650,5720,4200
4730 GO TO 4970
4740 REM            @    A    B    C    D    E    F    G
4750 GOSUB Ch8 OF 4200,4200,4200,6960,5830,5920,6580,6710
4760 GO TO 4970
4770 REM            H    I    J    K    L    M    N    O
4780 GOSUB Ch8 OF 6800,6840,6960,7110,7220,7310,4200,4200
4790 GO TO 4970
4800 REM            P    Q    R    S    T    U    V    W
4810 GOSUB Ch8 OF 4200,7420,6960,7460,7650,7690,7770,4200
4820 GO TO 4970
4830 REM            X    Y    Z    [    \    ]    ^    _
4840 GOSUB Ch8 OF 7920,4200,7970,4200,4200,4200,4200,4200
4850 GO TO 4970
4860 REM            `    a    b    c    d    e    f    g
4870 GOSUB Ch8 OF 4200,4200,4200,6960,5830,5920,6580,6710
4880 GO TO 4970
4890 REM            h    i    j    k    l    m    n    o
4900 GOSUB Ch8 OF 6800,6840,6960,7110,7220,7310,4200,4200
4910 GO TO 4970
4920 REM            p    q    r    s    t    u    v    w
4930 GOSUB Ch8 OF 4200,7420,6960,7460,7650,7690,7770,4200
4940 GO TO 4970
4950 REM            x    y    z    {    |    }    ~   ro
4960 GOSUB Ch8 OF 7920,4200,7970,4200,4200,4200,4200,8000
4970 LOOP 
4980 END SUB 
5000 REM ****** command execution ******
5010 REM ^A command ***********************************************
5020 CALL _search(Cmd$,"",Pc,1;I)
5030 IF I=0 THEN 
5040 CALL Err("unterminated ^A comand")
5050 END IF 
5060 CALL Lit_str(Cmd$,Pc,I-2)
5070 Pc=I
5080 RETURN 
5090 REM ^[ (escape) command **************************************
5100 Arg1=Undef
5110 Arg2=Undef
5120 Opr$=""
5130 RETURN 
5140 REM comma ***************************************************
5150 IF Arg1<>Undef THEN 
5160 CALL Unstack(0)
5170 Arg2=Arg1
5180 Arg1=Undef
5190 ELSE 
5200 CALL Err("comma without number")
5210 END IF 
5220 RETURN 
5230 REM times ***************************************************
5240 IF Pc>2 THEN 5280
5250 CALL Ch
5260 CALL Put_macro(Ch$,Last_cmd$,1,LEN(Last_cmd$)+1)
5270 GO TO 5090
5280 Opr$="*"
5290 GO TO 5350
5300 REM plus ****************************************************
5310 Opr$="+"
5320 GO TO 5350
5330 REM minus ***************************************************
5340 Opr$="-"
5350 Targ=Arg1*(Arg1<>Undef)  ! Temp argument
5360 RETURN 
5370 REM divide **************************************************
5380 Opr$="/"
5390 GO TO 5350
5400 REM dot *****************************************************
5410 Arg1=_dot-1
5420 GO TO 5460
5430 REM 0-9 *****************************************************
5440 Pc=Pc-1
5450 CALL Num_arg
5460 CALL Unstack(0)
5470 RETURN 
5480 REM : *******************************************************
5490 CALL Ch
5500 IF Ch$<>"g" THEN 
5510 CALL Err("colon what?")
5520 END IF 
5530 CALL Ch
5540 CALL Get_macro(Ch$,I1,I2)
5550 CALL Pr_substr(Macros$,I1,I2-1)
5560 GO TO 5090
5570 REM < *******************************************************
5580 CALL Uno_arg(1.0E+8)
5590 Bracket_count=Bracket_count+1
5600 IF Bracket_count>10 THEN 
5610 CALL Err("brackets nested too deeply")
5620 END IF 
5630 Bracket(Bracket_count)=Arg1+Pc/1000
5640 GO TO 5090
5650 REM equals **************************************************
5660 IF Arg1=Undef THEN 
5670 CALL Err("equals what?")
5680 END IF 
5690 CALL Uno_arg(0)
5700 PRINT Arg1
5710 GO TO 5090
5720 REM > *******************************************************
5730 IF Bracket_count<=0 THEN 
5740 CALL Err("missing left bracket")
5750 END IF 
5760 Bracket(Bracket_count)=Bracket(Bracket_count)-1
5770 IF Bracket(Bracket_count)<1 THEN 
5780 Bracket_count=Bracket_count-1
5790 ELSE 
5800 Pc=Bracket(Bracket_count)*1000 MOD 1000
5810 END IF 
5820 GO TO 5090
5830 REM D command ************************************************
5840 CALL Uno_arg(1)
5850 IF Arg1>0 THEN 
5860 Text$=REP("",_dot,Arg1)
5870 ELSE 
5880 Text$=REP("",_dot+Arg1,-Arg1)
5890 _dot=_dot+Arg1
5900 END IF 
5910 GO TO 5090
5920 REM E command ************************************************
5930 LOCAL _ch$,I
5940 DIM _ch$(1)
5950 CALL Ch
5960 IF Ch$="x" THEN 
5970 END 
5980 END IF 
5990 IF Ch$="g" THEN 
6000 PRINT "***calling ASSEM***"
6010 OLD "ASSEM"
6020 END IF 
6030 IF Ch$<>"r" AND Ch$<>"w" AND Ch$<>"c" THEN 
6040 CALL Err("illegal character after E")
6050 END IF 
6060 _ch$=Ch$
6070 CALL Arg
6080 IF NOT(LEN(Arg$)) THEN 
6090 PRINT "no file name/number supplied"
6100 ELSE 
6110 IF SEARCH(Arg$,"/:~",1)=0 THEN   !is a tape file
6120 F=VAL(Arg$)
6130 IF _ch$="r" THEN 
6140 PRINT "reading tape file #";F
6150 FIND F
6160 I=0  ! set to 1 by eof
6170 ON EOF (0) THEN 6190
6180 GO TO 6210
6190 I=1  ! eof interrupt routine
6200 RETURN 
6210 DO 
6220 INPUT @33:Line$
6230 EXIT IF I
6240 Text$=Text$&Line$&Cr$
6250 LOOP 
6260 ELSE 
6270 PRINT "writing tape file #";F
6280 FIND F
6290 PRINT @33:Text$;
6300 END IF 
6310 ELSE   ! a disk operation
6320 IF _ch$="r" THEN 
6330 PRINT "reading file ";Arg$
6340 OPEN Arg$;1,"r",File$
6350 PRINT File$
6360 I=0
6370 ON EOF (1) THEN 6190
6380 DO 
6390 INPUT #1:Line$
6400 EXIT IF I
6410 Text$=Text$&Line$&Cr$
6420 LOOP 
6430 ELSE 
6440 IF _ch$="w" THEN 
6450 PRINT "writing file ";Arg$
6460 OPEN Arg$;1,"f",File$
6470 PRINT File$
6480 PRINT #1:Text$;
6490 ELSE   ! ec command (deviant)
6500 CREATE Arg$,"a";1,0
6510 END IF 
6520 END IF 
6530 END IF 
6540 END IF 
6550 PRINT "done"
6560 CLOSE 
6570 GO TO 5090  ! join escape command to undefine args
6580 REM F command ************************************************
6590 CALL Ch
6600 IF Ch$="s" THEN 
6610 GOSUB 7460  ! do a search first
6620 ELSE 
6630 IF Ch$<>"r" THEN 
6640 CALL Err("illegal character after ""E""")
6650 END IF 
6660 END IF 
6670 CALL Arg
6680 Text$=REP(Arg$,_dot-LEN(Last_search$),LEN(Last_search$))
6690 _dot=_dot+LEN(Arg$)-LEN(Last_search$)
6700 RETURN 
6710 REM G command ************************************************
6720 CALL Ch
6730 CALL Get_macro(Ch$,I1,I2)
6740 LOCAL C$
6750 DIM C$(I2-I1+1)
6760 C$=SEG(Macros$,I1,I2-I1)
6770 Text$=REP(C$,_dot,0)
6780 _dot=_dot+LEN(C$)
6790 GO TO 5090
6800 REM H command ************************************************
6810 Arg1=LEN(Text$)
6820 Arg2=0
6830 RETURN 
6840 REM I command ************************************************
6850 IF Arg1=Undef THEN 
6860 CALL Arg
6870 Text$=REP(Arg$,_dot,0)
6880 _dot=_dot+LEN(Arg$)
6890 ELSE 
6900 CALL Unstack(0)
6910 Ch$=CHR(Arg1)
6920 Text$=REP(C$,_dot,0)
6930 _dot=_dot+1
6940 END IF 
6950 GO TO 5090
6960 REM J, C, and R commands *************************************
6970 CALL Uno_arg(Ch$<>"j")
6980 IF Ch$="c" THEN 
6990 Arg1=Arg1+_dot-1
7000 ELSE 
7010 IF Ch$="r" THEN 
7020 Arg1=_dot-Arg1-1
7030 END IF 
7040 END IF 
7050 IF Arg1=>0 AND Arg1<=LEN(Text$) THEN 
7060 _dot=Arg1+1
7070 ELSE 
7080 CALL Err("attempt to move out of buffer")
7090 END IF 
7100 GO TO 5090
7110 REM K command ************************************************
7120 CALL Two_args
7130 Text$=REP("",Arg1,Arg2-Arg1)
7140 IF Arg1<_dot THEN 
7150 IF Arg2>_dot THEN 
7160 _dot=Arg1
7170 ELSE 
7180 _dot=_dot-Arg2+Arg1
7190 END IF 
7200 END IF 
7210 GO TO 5090
7220 REM L command ************************************************
7230 CALL Uno_arg(1)
7240 CALL _search(Text$,Cr$,_dot,Arg1;I)
7250 IF NOT(I) THEN 
7260 _dot=(LEN(Text$)+1)*(Arg1>0)
7270 ELSE 
7280 _dot=I
7290 END IF 
7300 GO TO 5090
7310 REM M command ************************************************
7320 CALL Ch
7330 CALL Get_macro(Ch$,I1,I2)
7340 LOCAL Mc$
7350 DIM Mc$(I2-I1+1)
7360 Mc$=SEG(Macros$,I1,I2-I1+1)
7370 Bracket_count=Bracket_count+1
7380 Bracket(Bracket_count)=-(LEN(Cmd$)+Pc/1000)
7390 Pc=LEN(Cmd$)+1
7400 Cmd$=Cmd$&Mc$
7410 GO TO 5090
7420 REM Q command ************************************************
7430 CALL Mac_name(M)
7440 Arg1=Q_reg(M)
7450 RETURN 
7460 REM S command ************************************************
7470 LOCAL I
7480 CALL Uno_arg(1)
7490 CALL Arg
7500 IF NOT(LEN(Arg$)) THEN 
7510 Arg$=Last_search$
7520 ELSE 
7530 Last_search$=Arg$
7540 END IF 
7550 CALL _search(Text$,Arg$,_dot,Arg1;I)
7560 IF I>0 THEN 
7570 _dot=I
7580 Arg1=1
7590 ELSE 
7600 Arg1=0
7610 CALL Err("cannot find it")
7620 END IF 
7630 Arg2=Undef
7640 RETURN 
7650 REM T command ************************************************
7660 CALL Two_args
7670 CALL Pr_substr(Text$,Arg1,Arg2-1)
7680 GO TO 5090
7690 REM U command ************************************************
7700 CALL Uno_arg(Undef)
7710 IF Arg1=Undef THEN 
7720 CALL Err("argument required")
7730 END IF 
7740 CALL Mac_name(M)
7750 Q_reg(M)=Arg1
7760 GO TO 5090
7770 REM V command ************************************************
7780 CALL Uno_arg(1)
7790 Vi=Arg1
7800 IF Vi=1 THEN 
7810 PRINT 
7820 END IF 
7830 Arg1=1-Arg1
7840 GOSUB 7650
7850 IF Vi=1 THEN 
7860 PRINT "!v
";
7870 END IF 
7880 Arg1=Vi
7890 Arg2=Undef
7900 GOSUB 7650
7910 RETURN 
7920 REM X command ************************************************
7930 CALL Two_args
7940 CALL Ch
7950 CALL Put_macro(Ch$,Text$,Arg1,Arg2)
7960 GO TO 5090
7970 REM Z command ************************************************
7980 Arg1=LEN(Text$)
7990 GO TO 5460
8000 REM ro command (end of macro) ********************************
8010 IF Bracket_count<=0 THEN 
8020 CALL Err("rubout command?")
8030 END IF 
8040 Cmd$=SEG(Cmd$,1,INT(-Bracket(Bracket_count)))
8050 Pc=-Bracket(Bracket_count)*1000 MOD 1000
8060 Bracket_count=Bracket_count-1
8070 GO TO 5090
10000 SUB Ch
10010 IF Pc<=LEN(Cmd$) THEN 
10020 Ch$=SEG(Cmd$,Pc,1)
10030 Ch=ASC(Ch$)
10040 Pc=Pc+1
10050 ELSE 
10060 Ch$=""
10070 Ch=Undef
10080 END IF 
10090 END SUB 
11000 SUB Err(Err$)
11010 PRINT Err$
11020 NEXT Cmd_no  !cheap escape
11030   !END SUB
12000 SUB Two_args
12010 REM converts one arg to two (if necessary)
12020 CALL Unstack(1)
12030 IF Arg2=Undef THEN 
12040 CALL _search(Text$,Cr$,_dot,Arg1;Arg2)
12050 IF Arg2=0 THEN 
12060 Arg2=LEN(Text$)*(Arg1>0)+1
12070 END IF 
12080 Arg1=_dot
12090 ELSE   ! user expects zero based input -- text$ is one based
12100 Arg1=Arg1+1
12110 Arg2=Arg2+1
12120 END IF 
12130 IF Arg1>Arg2 THEN 
12140 T=Arg1
12150 Arg1=Arg2
12160 Arg2=T
12170 END IF 
12180 IF _trace THEN 
12190 PRINT "args are";Arg1;",";Arg2
12200 END IF 
12210 END IF 
12220 END SUB 
13000 SUB _search(A$,F$,P,N;L)
13010 IF _trace THEN 
13020 PRINT "search for ";F$,P,N
13030 END IF 
13040 LOCAL Ii,N1
13050 IF N>0 THEN 
13060 L=P
13070 FOR Ii=1 TO N
13080 L=POS(A$,F$,L)
13090 IF L=0 THEN 13120
13100 L=L+LEN(F$)
13110 NEXT Ii
13120 ELSE   ! negative search
13130 N1=0
13140 L=1
13150 DO 
13160 L=POS(A$,F$,L)
13170 EXIT IF L=>P OR L=0
13180 N1=N1+1
13190 L=L+LEN(F$)
13200 LOOP 
13210 L=0
13220 IF N1+N>0 THEN 
13230 FOR Ii=1 TO N1+N
13240 L=POS(A$,F$,L)+LEN(F$)
13250 NEXT Ii
13260 END IF 
13270 END IF 
13280 IF _trace THEN 
13290 PRINT "found at ";L
13300 END IF 
13310 END SUB 
14000 SUB Arg
14010 LOCAL I
14020 CALL _search(Cmd$,Esc$,Pc,1;I)
14030 IF NOT(I) THEN 
14040 CALL Err("unterminated string argument")
14050 END IF 
14060 Arg$=SEG(Cmd$,Pc,I-Pc-1)
14070 IF _trace THEN 
14080 PRINT "arg=";
14090 CALL Pr_string(Arg$)
14100 END IF 
14110 Pc=I
14120 END SUB 
15000 SUB Num_arg
15010 LOCAL I
15020 I=SEARCH(Cmd$,"/:~",Pc)
15030 Line$=SEG(Cmd$,Pc,I-Pc)
15040 IF LEN(Line$) THEN 
15050 Arg1=VAL(Line$)
15060 Pc=Pc+LEN(Line$)
15070 ELSE 
15080 Arg1=Undef
15090 END IF 
15100 END SUB 
16000 SUB Uno_arg(D_falt)
16010 IF Arg2<>Undef THEN 
16020 CALL Err("one argument only")
16030 END IF 
16040 CALL Unstack(D_falt)
16050 END SUB 
16060 SUB Unstack(D_falt)
16070 IF Arg1=Undef THEN 
16080 Arg1=D_falt
16090 END IF 
16100 IF Opr$="-" THEN 
16110 Arg1=Targ-Arg1
16120 ELSE 
16130 IF Opr$="+" THEN 
16140 Arg1=Targ+Arg1
16150 ELSE 
16160 IF Opr$="*" THEN 
16170 Arg1=Targ*Arg1
16180 ELSE 
16190 IF Opr$="/" THEN 
16200 Arg1=INT(Targ/Arg1)
16210 END IF 
16220 END IF 
16230 END IF 
16240 END IF 
16250 Opr$=""
16260 END SUB 
17000 SUB Put_macro(Mac$,From$,I1,I2)
17010 LOCAL I3,I4,Mymac$
17020 CALL Get_macro(Mac$,I3,I4)
17030 DELETE Mymac$
17040 DIM Mymac$(I2-I1)
17050 Mymac$=SEG(From$,I1,I2-I1)
17060 Macros$=REP(Mymac$,I3,I4-I3)
17070 END SUB 
18000 SUB Get_macro(Mac$,I1,I2)
18010 LOCAL Mymac$
18020 DIM Mymac$(2)
18030 Mymac$=Eom$&Mac$
18040 I1=POS(Macros$,Mymac$,1)
18050 IF I1=0 THEN 
18060 CALL Err("illegal macro name")
18070 END IF 
18080 I1=I1+2
18090 I2=POS(Macros$,Eom$,I1)
18100 END SUB 
18110 SUB Mac_name(M)
18120 CALL Ch
18130 M=ASC(Ch$)
18140 IF M=>ASC("0") AND M<=ASC("9") THEN 
18150 M=M-ASC("0")+1
18160 ELSE 
18170 IF M=>ASC("A") AND M<=ASC("Z") THEN 
18180 M=M-ASC("A")+11
18190 ELSE 
18200 IF M=>ASC("a") AND M<=ASC("z") THEN 
18210 M=M-ASC("a")+11
18220 ELSE 
18230 CALL Err("illegal macro name")
18240 END IF 
18250 END IF 
18260 END IF 
18270 END SUB 
