99 REM    5100-6110/0 Modified for Flash Drive by mcm 11 Nov 2024100 REM   +--------------------------------------+110 REM   |    M6800 DISSASSEMBLER in BASIC      |120 REM   |     by Ed Sawicki and Joe Boim       |130 REM   |      TEKTRONIX - Long Island         |140 REM   |         April 18,1978                |150 REM   +--------------------------------------+160 INIT 170 SET NOCASE 180 DIM N$(1400),B$(1),M$(4),A$(MEMORY-1000),C$(4),V$(4),R(4),K(4)190 DIM H$(16),C$(4),P$(1),Q$(2),Y$(4)200 READ K210 DATA 4096,256,16,1220 C$="0000"230 PRINT "ENTER NAME OF PROGRAM TO BE DISASSEMBLED :";240 INPUT I$250 PRINT "OBJECT CODE Flash Drive FILE NUMBER :";260 INPUT E270 FIND @5:E280 INPUT @5:A$290 REM PRINT "ENTER OUTPUT Flash Drive ADDRESS :";300 D=5320 PRINT "Flash Drive FILE NUMBER FOR OUTPUT :";330 INPUT F340 FIND @5:F350 PRINT "ENTER ORIGIN IN HEX :";360 INPUT V$370 REM Hex/Decimal conversion380 H$="0123456789ABCDEF"390 Z=-1400 FOR I=1 TO 4410 X$=SEG(V$,I,1)420 Z=Z+(POS(H$,X$,1)-1)*K(I)430 NEXT I440 REM IMM #   DIRECT *   INDEX X   EXTENDED &   IMPLIED !  RELATIVE %450 N$="86ldaa#96ldaa*A6ldaaXB6ldaa&C6ldab#D6ldab*E6ldabXF6ldab&"460 N$=N$&"97staa*A7staaXB7staa&D7stab*E7stabXF7stab&36psha!37pshb!"470 N$=N$&"ADjsr XBDjsr &01nop !39rts !8Dbsr %27beq %26bne %20bra %"480 N$=N$&"24bcc %25bcs %08inx !6Cinc X7Cinc &4Cinca!5Cincb!4Fclra!"490 N$=N$&"5Fclrb!6Fclr X7Fclr &8Badda#9Badda*ABaddaXBBadda&CBaddb#"500 N$=N$&"DBaddb*EBaddbXFBaddb&1Baba !89adca#99adca*A9adcaXB9adca&"510 N$=N$&"C9adcb#D9adcb*E9adcbXF9adcb&84anda#94anda*A4andaXB4anda&"520 N$=N$&"C4andb#D4andb*E4andbXF4andb&6Ejmp X7Ejmp &32pula!33pulb!"530 N$=N$&"81cmpa#91cmpa*A1cmpaXB1cmpa&C1cmpb#D1cmpb*E1cmpbXF1cmpb&"540 N$=N$&"5Dtstb!4Dtsta!6Dtst X7Dtst &17tba !16tab !10sba !54lsrb!"550 N$=N$&"C2sbcb#D2sbcb*E2sbcbXF2sbcb&82sbca#92sbca*A2sbcaXB2sbca&"560 N$=N$&"C0subb#D0subb*E0subbXF0subb&80suba#90suba*A0subaXB0suba&"570 N$=N$&"44lsra!64lsr X74lsr &57asrb!47asra!67asr X77asr &58aslb!"580 N$=N$&"48asla!68asl X78asl &56rorb!46rora!66ror X76ror &59rolb!"590 N$=N$&"49rola!69rol X79rol &CAorab#DAorab*EAorabXFAorab&8Aoraa#"600 N$=N$&"9Aoraa*AAoraaXBAoraa&C8eorb#D8eorb*E8eorbXF8eorb&88eora#"610 N$=N$&"98eora*A8eoraXB8eora&50negb!40nega!60neg X70neg &53comb!"620 N$=N$&"43coma!63com X73com &2Bbmi %2Cbge %2Abpl %22bhi %11cba !"630 N$=N$&"8Ccpx #9Ccpx *ACcpx XBCcpx &09dex !34des !31ins !CEldx #"640 N$=N$&"DEldx *EEldx XFEldx &8Elds #9Elds *AElds XBElds &DFstx *"650 N$=N$&"EFstx XFFstx &9Fsts *AFsts XBFsts &85bita#95bita*A5bitaX"660 N$=N$&"B5bita&C5bitb#D5bitb*E5bitbXF5bitb&"670 N$=N$&"3Ewai !3Fswi !3Brti !30tsx !35txs !19daa !23bls %29bvs %"680 N$=N$&"07tpa !06tap !0Bsev !0Fsei !0Dsec !0Aclv !0Ecli !0Cclc !"690 N$=N$&"6Adec X7Adec &4Adeca!5Adecb!2Ebgt %2Fble %2Dblt %28bvc %"700 PRINT @D: USING "P20TFALL":"MC6800 DISASSEMBLER  V1.1"710 PRINT @D: USING "20TFALL":I$720 REM object code to be disassembled is in A$730 FOR I=1 TO LEN(A$)740 C=INT(I/2+1)750 I$=SEG(A$,I,2)760 REM Search the table(N$) for op code(I$) - mnemonic returned in M$770 REM address mode symbol is returned in B$780 P=POS(N$,I$,1)790 IF P<>0 THEN 840800 B$="!"810 M$="DATA"820 GO TO 950830 REM Get the mnemonic840 M$=SEG(N$,P+2,4)850 REM Get the addressing mode symbol860 B$=SEG(N$,P+6,1)870 REM Convert the mnemonic to upper case880 FOR I1=1 TO 4890 X$=SEG(M$,I1,1)900 IF ASC(X$)<97 THEN 940910 X=ASC(X$)-32920 X$=CHR(X)930 M$=REP(X$,I1,1)940 NEXT I1950 F=1960 P$=" "970 Q$=P$980 X$=P$990 REM Branch if implied1000 IF B$="!" THEN 14601010 F=31020 IF B$<>"#" THEN 11201030 REM IMMEDIATE addressing mode1040 P$="#"1050 X$=SEG(M$,3,1)1060 IF X$="X" OR X$="S" THEN 10901070 X$=SEG(A$,I+2,2)1080 GO TO 14601090 X$=SEG(A$,I+2,4)1100 F=51110 GO TO 14601120 IF B$<>"*" THEN 11701130 REM DIRECT addressing mode1140 Q$=",D"1150 X$=SEG(A$,I+2,2)1160 GO TO 14601170 IF B$<>"X" THEN 12201180 REM INDEXED addressing mode1190 Q$=",X"1200 X$=SEG(A$,I+2,2)1210 GO TO 14601220 IF B$<>"%" THEN 14401230 REM RELATIVE addressing mode1240 X$=SEG(A$,I+2,2)1250 Y$=SEG(X$,1,1)1260 REM Test for backward branch1270 IF ASC(Y$)>55 THEN 13301280 X=VAL(Y$)*161290 Y$=SEG(X$,2,1)1300 X=ASC(Y$)+X+INT(I/2+1)-((ASC(Y$)=>58)*7+46)1310 GO TO 13701320 REM we get here if branch is backward1330 X=(ASC(Y$)-((ASC(Y$)>57)*7+56))*161340 Y$=SEG(X$,2,1)1350 X=X+ASC(Y$)-((ASC(Y$)>57)*7+48)1360 X=C-(126-X)1370 GOSUB 15401380 V$=C$1390 A=X+Z1400 GOSUB 15501410 PRINT @D: USING "FD7T4A13T2A4A27T4A34TFA40T"";""":C,V$,I$,X$,M$,C$1415 PRINT USING "FD7T4A13T2A4A27T4A34TFA40T"";""":C,V$,I$,X$,M$,C$1420 GO TO 14901430 REM MUST BE EXTENDED IF WE GET HERE1440 F=51450 X$=SEG(A$,I+2,4)1460 GOSUB 15401470 PRINT @D: USING 1480:C,C$,I$,X$,M$,P$,X$,Q$1475 PRINT USING 1480:C,C$,I$,X$,M$,P$,X$,Q$1480 IMAGE FD7T4A13T2A4A27T4A33T1AFA2A40T";"1490 I=I+F1500 NEXT I1510 PRINT @D: USING "LLFA":"FINISHED !"1515 PRINT USING "LLFA":"FINISHED !"1520 END 1530 REM Decimal to Hex Subroutine1540 A=C+Z1550 FOR I1=1 TO 41560 R(I1)=INT(A/K(I1))1570 A=A-K(I1)*R(I1)1580 Y$=SEG(H$,R(I1)+1,1)1590 C$=REP(Y$,I1,1)1600 NEXT I11610 RETURN 